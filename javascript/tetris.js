// Generated by CoffeeScript 1.6.3
(function() {
  (typeof exports !== "undefined" && exports !== null ? exports : this).tetris = (function() {
    var $CONTAINER, CANVAS, CELL_PADDING, CELL_SIZE, COLOURS, CONTEXT, GAMES, GAMES_PER_ROW, GAME_HEIGHT, GAME_WIDTH, INFO_HEIGHT, POPULATION_SIZE, ROWS, best, init, kill, toUpdate, update, _move, _resize;
    COLOURS = [null, '#000000', '#222222', '#444444', '#666666', '#888888', '#AAAAAA', '#CCCCCC'];
    $CONTAINER = CANVAS = GAMES = CONTEXT = GAME_WIDTH = GAME_HEIGHT = CELL_PADDING = CELL_SIZE = INFO_HEIGHT = null;
    POPULATION_SIZE = 32;
    GAMES_PER_ROW = 12;
    ROWS = 3;
    best = null;
    toUpdate = [];
    _resize = function() {
      CANVAS.width = $CONTAINER.innerWidth() - 50;
      CANVAS.height = $CONTAINER.innerHeight() - 50;
      GAME_WIDTH = CANVAS.width / GAMES_PER_ROW;
      CELL_PADDING = 10;
      CELL_SIZE = (GAME_WIDTH - CELL_PADDING * 2) / 10;
      GAME_HEIGHT = CELL_SIZE * 20;
      return GAME_HEIGHT += (CANVAS.height - (ROWS * GAME_HEIGHT)) / ROWS;
    };
    _move = function(tetris, index) {
      if (best === null) {
        best = tetris;
        best.index = index + 1;
        best.generation = Genie.getGeneration();
      } else if (tetris.score > best.score) {
        best = tetris;
        best.index = index + 1;
        best.generation = Genie.getGeneration();
      }
      return toUpdate.push({
        tetris: tetris,
        index: index
      });
    };
    init = function($container) {
      var genieInit;
      $CONTAINER = $container;
      $CONTAINER.empty();
      CANVAS = $('<canvas>').get(0);
      $CONTAINER.append(CANVAS);
      CONTEXT = CANVAS.getContext('2d');
      $(window).resize(_resize);
      if (WorkerBench.workersAvailable() && false) {
        genieInit = function() {
          _resize();
          Genie.init({
            workerMessageHandler: function(e) {
              switch (e.data.func) {
                case 'move':
                  _move(e.data.tetris, e.data.index);
                  return e.target.postMessage({
                    func: 'update'
                  });
                case 'complete':
                  return Genie.reportFitness(e.data.score, e.data.index);
              }
            },
            workerScriptPath: '/javascript/tetrisWorker.js',
            useWorkers: WorkerBench.result(),
            logging: true,
            numberOfGenes: 8
          });
          return Genie.run();
        };
        WorkerBench.init({
          onComplete: genieInit
        });
        return WorkerBench.start();
      } else {
        _resize();
        Genie.init({
          evaluateFitness: function(chromosome, chromosomeIndex) {
            var tetris, update;
            tetris = new TetrisAI(chromosome.genes);
            update = function() {
              debugger;
              if (tetris.gameOver()) {
                return Genie.reportFitness(tetris.score, chromosomeIndex);
              } else {
                _move(tetris, chromosomeIndex);
                tetris.makeMove();
                return requestAnimFrame(update);
              }
            };
            return update();
          },
          logging: true,
          numberOfGenes: 8,
          useWorkers: false
        });
        return Genie.run();
      }
    };
    update = function() {
      var fillX, fillY, game, value, x, xIndex, y, yIndex, _i, _j, _k, _len;
      for (_i = 0, _len = toUpdate.length; _i < _len; _i++) {
        game = toUpdate[_i];
        xIndex = game.index % GAMES_PER_ROW;
        yIndex = Math.floor(game.index / GAMES_PER_ROW);
        CONTEXT.clearRect(xIndex * GAME_WIDTH + CELL_PADDING, yIndex * GAME_HEIGHT + CELL_PADDING, GAME_WIDTH, GAME_HEIGHT);
        CONTEXT.fillStyle = 'rgba(0, 0, 0, 0.1)';
        CONTEXT.fillRect(xIndex * GAME_WIDTH + CELL_PADDING, yIndex * GAME_HEIGHT + CELL_PADDING, CELL_SIZE * 10, CELL_SIZE * 20);
        if (game.tetris != null) {
          for (x = _j = 0; _j < 10; x = ++_j) {
            for (y = _k = 0; _k < 20; y = ++_k) {
              value = game.tetris.grid[y + 1][x + 1];
              if (value !== 0 && value !== 8 && value !== 9 && value !== (-2) && value !== (-3)) {
                CONTEXT.fillStyle = COLOURS[value];
                fillX = x * CELL_SIZE + 1 + xIndex * GAME_WIDTH + CELL_PADDING;
                fillY = y * CELL_SIZE + 1 + yIndex * GAME_HEIGHT + CELL_PADDING;
                CONTEXT.fillRect(fillX, fillY, CELL_SIZE - 2, CELL_SIZE - 2);
              }
            }
          }
          game.update = false;
          CONTEXT.font = 'bold 30px College';
          CONTEXT.fillStyle = '#444499';
          CONTEXT.fillText(game.index + 1, xIndex * GAME_WIDTH + CELL_PADDING + 5, yIndex * GAME_HEIGHT + CELL_PADDING + 25);
          CONTEXT.font = 'bold 15px College';
          CONTEXT.fillStyle = '#44BB44';
          CONTEXT.fillText(game.tetris.score, xIndex * GAME_WIDTH + CELL_PADDING + 5, yIndex * GAME_HEIGHT + CELL_PADDING + 50);
        }
      }
      toUpdate = [];
      if (best) {
        CONTEXT.font = 'bold 30px College';
        CONTEXT.clearRect(GAME_WIDTH * 8, (GAME_HEIGHT + INFO_HEIGHT) * 2, 400, 150);
        CONTEXT.fillStyle = '#444499';
        CONTEXT.fillText('BEST SCORE: ', GAME_WIDTH * 8 + 10, GAME_HEIGHT * 2 + 30);
        CONTEXT.fillText('GENERATION: ', GAME_WIDTH * 8 + 10, GAME_HEIGHT * 2 + 70);
        CONTEXT.fillText('CANDIDATE: ', GAME_WIDTH * 8 + 10, GAME_HEIGHT * 2 + 110);
        CONTEXT.fillStyle = '#449944';
        CONTEXT.fillText((best != null ? best.score : void 0) || '', GAME_WIDTH * 8 + 200, GAME_HEIGHT * 2 + 30);
        CONTEXT.fillText((best != null ? best.generation : void 0) || '', GAME_WIDTH * 8 + 200, GAME_HEIGHT * 2 + 70);
        return CONTEXT.fillText((best != null ? best.index : void 0) || '', GAME_WIDTH * 8 + 200, GAME_HEIGHT * 2 + 110);
      }
    };
    kill = function() {
      return Genie.kill();
    };
    return {
      init: init,
      update: update,
      kill: kill
    };
  })();

}).call(this);
